# Guide: Solving Princeton's Algorithms Assignments

This guide documents the complete process used to solve the six programming assignments from Princeton's Algorithms, Part I course, including code implementation, testing, and the generation of a final report with graphical flowcharts.

---

### Chapter 1: Initial Setup

1.  **Directory Structure**: A main folder `finalAnswers` was created. Inside, a separate subdirectory was made for each problem set (`problemSet1`, `problemSet2`, etc.) to keep all related files organized.

2.  **Core Libraries**: The course provides a standard library, `algs4.jar`. This was downloaded from the course website (`http://algs4.cs.princeton.edu/code/algs4.jar`) and placed in each problem set's directory to be used during compilation and execution.

---

### Chapter 2: Solving the Assignments

Each of the six problem sets was solved according to its specification.

-   **Problem Set 1 (Hello, World)**: Implemented basic Java applications to handle standard I/O and command-line arguments.
-   **Problem Set 2 (Percolation)**: Implemented the percolation model using the Weighted Quick-Union Find algorithm to estimate the percolation threshold via Monte Carlo simulation.
-   **Problem Set 3 (Queues)**: Implemented a double-ended queue (`Deque`) with a doubly-linked list and a `RandomizedQueue` with a resizing array.
-   **Problem Set 4 (Collinear Points)**: Implemented brute-force and sorting-based algorithms to find collinear points in a set.
-   **Problem Set 5 (8 Puzzle)**: Implemented the A* search algorithm to solve the 8-puzzle problem. The `Board` data type was optimized to cache the Manhattan distance, and the `Solver` was refined to handle unsolvable puzzles efficiently by running a parallel search on a "twin" board.
-   **Problem Set 6 (Kd-Tree)**: Implemented a brute-force `PointSET` and an optimized `KdTree` to support 2D range search and nearest-neighbor search.

---

### Chapter 3: The Flowchart Challenge

Generating graphical flowcharts in the command-line environment proved to be the most complex part of the task.

#### Attempt 1: Mermaid.js + Web Services (Failed)

-   **Idea**: Pass Mermaid diagram code to a web service (like `mermaid.ink`) to render images.
-   **Problem**: This was unreliable. The service frequently timed out or returned errors due to network issues or minor syntax sensitivities in the diagram code for more complex flowcharts.

#### Attempt 2: Local Mermaid CLI (`mmdc`) (Failed)

-   **Idea**: Install and run the official Mermaid command-line tool locally.
-   **Problem**: This tool depends on Puppeteer, which in turn depends on a full Chrome/Chromium browser instance. The Termux environment could not support this dependency, even after installing community-packaged versions of Chromium and Firefox. The tool would either fail to install or time out when trying to launch the headless browser.

#### Final Solution: Graphviz (Success)

-   **Idea**: Use a different, more stable, and environment-independent diagramming tool. Graphviz is a mature open-source tool that renders diagrams from a simple `DOT` language and has no browser dependency.
-   **Process**:
    1.  **Installation**: Graphviz was installed via `pkg install graphviz`.
    2.  **Translation**: Each Mermaid flowchart was manually translated into the DOT language. For example:

        *Mermaid Code:*
        ```mermaid
        graph TD;
            A((Start)) --> B[/Input/];
            B --> C((End));
        ```

        *DOT Code:*
        ```dot
        digraph G {
            rankdir="TB";
            A [label="Start", shape=oval];
            B [label="Input", shape=parallelogram];
            C [label="End", shape=oval];
            A -> B -> C;
        }
        ```
    3.  **Image Generation**: The `dot` command was used to convert each `.dot` script into a PNG image. The command for each flowchart was:
        ```bash
        dot -Tpng [input_file.dot] -o [output_file.png]
        ```

This approach was successful and produced a local PNG image for every flowchart.

---

### Chapter 4: Compiling the Final Report

1.  **HTML Compilation**: A master HTML file (`All_Solutions.html`) was created. This file was structured to present the solution for each problem set, including the test output and the flowchart images generated by Graphviz, which were embedded using standard `<img>` tags.

2.  **CSS for Scaling**: To solve the issue of large images being cut off in the PDF, CSS was added to the HTML file. The rule `img { max-width: 100%; height: auto; }` ensures that images automatically scale down to fit the width of the page.

3.  **Final PDF Generation**: The `weasyprint` tool was used to convert the final, polished HTML file into the deliverable `All_Solutions.pdf`.
    ```bash
    weasyprint finalAnswers/All_Solutions.html finalAnswers/All_Solutions.pdf
    ```

This systematic process ensured all requirements were met, overcoming environmental limitations to produce a complete and well-formatted final report.
